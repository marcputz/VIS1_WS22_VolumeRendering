precision highp float;
precision mediump sampler3D;

uniform sampler3D data;
uniform sampler2D backSideTexture;
uniform sampler2D frontSideTexture;
uniform int canvasWidth;
uniform int canvasHeight;
uniform float volumeScale;

const int MAX_STEPS = 1024;
const float STEP_SIZE = 0.2;

vec3 getBackSideCoords(vec2 fragCoords);
vec3 getFrontSideCoords(vec2 fragCoords);
vec3 getRay(vec2 fragCoords);

float raycast_mip(vec3 startPos, vec3 endPos, vec3 rayDirection, int nSteps);

float getDensity(vec3 dataPosition);
vec4 valueToColor(float val);

void main(){

    // get the fragments position
    vec2 fragPos = vec2(gl_FragCoord.x / float(canvasWidth), gl_FragCoord.y / float(canvasHeight));

    // get ray direction and length
    vec3 ray = getRay(fragPos);
    vec3 rayDirection = normalize(ray);
    float rayLength = length(ray);

    // get starting and ending positions of the ray on the bounding box
    vec3 startPos = getFrontSideCoords(fragPos);
    vec3 endPos = getBackSideCoords(fragPos);

    // calculate the number of steps by dividing the length of the ray throught the relative step size
    // IMPORTANT: Step size is given in the volume's coordinates, so it has to be scaled down accordingly first
    int nSteps = int(floor(rayLength / (STEP_SIZE / volumeScale)));
    if (nSteps < 1) {
        discard;
    }

    // sample the data values by the chosen raycasting method
    float density = raycast_mip(startPos, endPos, rayDirection, nSteps);

    gl_FragColor = valueToColor(density);

    return;
}

float getDensity(vec3 dataPosition) {
    return texture(data, dataPosition).r;
}

vec4 valueToColor(float val) {
    return vec4(vec3(1.0, 1.0, 1.0) * val, 1.0);
}

vec3 getBackSideCoords(vec2 fragCoords) {
    return texture2D(backSideTexture, fragCoords).xyz;
}

vec3 getFrontSideCoords(vec2 fragCoords) {
    return texture2D(frontSideTexture, fragCoords).xyz;
}

vec3 getRay(vec2 fragCoords) {
    vec3 frontSideCoords = getFrontSideCoords(fragCoords);
    vec3 backSideCoords = getBackSideCoords(fragCoords);

    return (backSideCoords - frontSideCoords);
}

float raycast_mip(vec3 startPos, vec3 endPos, vec3 rayDirection, int nSteps) {

    float maxVal = -1e6;
    vec3 loc = startPos;
    vec3 locColor;

    for (int i = 0; i < MAX_STEPS; i++) {
        if (i >= nSteps) {
            break;
        }
        float val = getDensity(loc);
        if (val > maxVal) {
            maxVal = val;
            locColor = loc;
        }
        loc += (rayDirection * (STEP_SIZE / volumeScale));
    }

    return maxVal;
}